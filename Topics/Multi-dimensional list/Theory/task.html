<h2>Multi-dimensional list</h2>
<p>You are already familiar with one-dimensional lists. Now, we’re going to look at multi-dimensional lists with two or even more dimensions in Kotlin. You'll learn how to create such lists and how to manage their contents.</p><h5 id="a-list-of-lists">A list of lists</h5><p>First, let's figure what we mean by a <strong>multi-dimensional list</strong>.</p><p>Basically, we can say that a multi-dimensional list is a list of lists. That is, in order to create a multi-dimensional list, we need to present a list as an element of another list. Eventually, we get a multi-dimensional list.</p><p>Such lists make it very easy to represent things that have many dimensions: for example, 3D objects with length, height, and width. The universe we live in could be described with four measurements, time being the fourth dimension, so it is 4D. Higher levels, like 5D and so forth, are hard to imagine, but when you put the concept into practice, they turn out to be handy and not too complicated!</p><p>Let's look at some more down-to-earth examples. A seat in the theater can be indicated with a 2D-list: one index for the row and another one for the number of the seat in that row. If you want to write a game that uses maps, such as Sea Battle, two-dimensional lists will be very helpful in setting coordinates on the map. In addition, some mathematical structures are conveniently represented as multi-dimensional lists.</p><p>First, let’s take a look at a special case of a multi-dimensional list that is used quite often in practice: a <strong>two-dimensional list</strong>.</p><h5 id="creating-2-dimensional-lists">Creating 2-dimensional lists</h5><p>While a one-dimensional list can be represented as a single sequence of elements, an intuitive way of representing a two-dimensional list is a <strong>matrix</strong> or a <strong>table</strong>. If you're working with matrices or tables in your program, it makes sense to present them in the form of a two-dimensional list.</p><p>Let's create a two-dimensional mutable list of <code class="language-kotlin">Int</code> with 3 rows and 4 columns where all elements are 0's (zeros). Here is what it looks like:</p><pre><code class="language-kotlin">val mutList2D = mutableListOf(
    mutableListOf&lt;Int&gt;(0, 0, 0, 0),
    mutableListOf&lt;Int&gt;(0, 0, 0, 0),
    mutableListOf&lt;Int&gt;(0, 0, 0, 0)
)</code></pre><p>You simply define each element of the <code class="language-kotlin">mutList2D</code> as a list of four zeros! It is easy to picture it like this:</p><table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td></tr><tr><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td></tr><tr><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td></tr></tbody></table><p>We can say that the lists with four zero elements are <strong>nested</strong> in the <code class="language-kotlin">mutList2D</code>. The list that contains other lists is called the <strong>main</strong> list.</p><p>Note an interesting feature: nested lists do not necessarily have to be the same size. In the example below, each new embedded list has a different length:</p><pre><code class="language-kotlin">val mutList2D = mutableListOf(
    mutableListOf&lt;Int&gt;(0),
    mutableListOf&lt;Int&gt;(1, 2),
    mutableListOf&lt;Int&gt;(3, 4, 5)
)</code></pre><p></p><div class="alert alert-primary"><p>You can create nested lists with different numbers of elements in the same 2D list.</p></div><p></p><h5 id="accessing-elements"> Accessing elements</h5><p>Let’s see how we can access an element of a list. The principle is exactly the same as for one-dimensional lists. Only now we have to write <strong>two</strong> indices: first, the index of the element of the main list and then, the index of the nested list.</p><p>Let's get back to our <code class="language-kotlin">mutList2D</code> for a moment. Suppose we need to access an element that is in the first row and the first column. How do we find this particular element? As you recall, <code class="language-kotlin">mutList2D</code> is a list of lists. So, start by selecting one of the nested lists by its index in the main list. The principle is similar to a 1D list.</p><p>First, go to the nested lists and choose the inner list with its index:</p><pre><code class="language-kotlin">val mutList2D = mutableListOf(
    mutableListOf&lt;Int&gt;(0, 1, 2),   //[0]
    mutableListOf&lt;Int&gt;(3, 4, 5)    //[1]  
)</code></pre><table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td><p><strong>mutList2D[0]</strong></p></td><td><p><strong>0</strong></p></td><td><p><strong>1</strong></p></td><td><p><strong>2</strong></p></td></tr><tr><td><p><strong>mutList2D[1]</strong></p></td><td><p>3</p></td><td><p>4</p></td><td><p>5</p></td></tr></tbody></table><p>Second, in this nested list, choose the required element with its index, just like we did with 1D lists:</p><table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td><p><strong>mutList2D[0][0]</strong></p></td><td><p><strong>mutList2D[0][1]</strong></p></td><td><p><strong>mutList2D[0][2]</strong></p></td></tr><tr><td><p><strong>0</strong></p></td><td><p>1</p></td><td><p>2</p></td></tr></tbody></table><p>Let's print <code class="language-kotlin">mutList2D[0][0]</code>: the element in the first row and the first column of our <code class="language-kotlin">mutList2D</code>:</p><pre><code class="language-kotlin">val mutList2D = mutableListOf(
    mutableListOf&lt;Int&gt;(0, 1, 2),   //[0]
    mutableListOf&lt;Int&gt;(3, 4, 5)    //[1]  
)

println(mutList2D[0][0])	// 0</code></pre><p></p><div class="alert alert-warning"><p>Remember that in all lists indexing starts with 0! </p></div><p></p><p>The following code will show all the elements of the two-dimensional list <code class="language-kotlin">mutList2D</code>:</p><pre><code class="language-kotlin">print(mutList2D[0][0])  // 0
print(mutList2D[0][1])  // 1
print(mutList2D[0][2])  // 2
print(mutList2D[1][0])  // 3
print(mutList2D[1][1])  // 4
print(mutList2D[1][2])  // 5</code></pre><h5 id="creating-2d-lists-of-different-types">Creating 2D lists of different types</h5><p>Nested lists don't need to be of type <code class="language-kotlin">Int</code>: as you remember, Kotlin provides various types of lists. For example, you can create a list of string lists as in the example below.</p><p>You can also clearly define the type of elements of nested lists:</p><pre><code class="language-kotlin">val mutListOfString2D = mutableListOf(
    mutableListOf&lt;String&gt;("to", "be", "or"),
    mutableListOf&lt;String&gt;("not", "to", "be")
)
</code></pre><p>In order to create nested lists of primitives, you can use lists of a certain type as we did for one-dimensional lists: <code class="language-kotlin">Int</code>, <code class="language-kotlin">Long</code>, <code class="language-kotlin">Double</code>, <code class="language-kotlin">Float</code>, <code class="language-kotlin">Char</code>, <code class="language-kotlin">Short</code>, <code class="language-kotlin">Byte</code>, and <code class="language-kotlin">Boolean</code>. </p><p>For example, let's consider creating a mutable list of the character type:</p><pre><code class="language-kotlin">val mutListOfChar2D = mutableListOf(
    mutableListOf&lt;Char&gt;('A', 'R', 'R'),
    mutableListOf&lt;Char&gt;('A', 'Y', 'S')
)</code></pre><p>You can imagine it like this:</p><table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td><p>A</p></td><td><p>R</p></td><td><p>R</p></td></tr><tr><td><p>A</p></td><td><p>Y</p></td><td><p>S</p></td></tr></tbody></table><p>Besides, nested lists can be of different types. For example, you can create a two-dimensional list that stores both <code class="language-kotlin">Int</code> and <code class="language-kotlin">String</code> lists:</p><pre><code class="language-kotlin">val mutListOfStringAndInt2D = mutableListOf(
    mutableListOf&lt;String&gt;("Practice", "makes", "perfect"),
    mutableListOf&lt;Int&gt;(1, 2)
)</code></pre><p></p><div class="alert alert-primary"><p>You can create nested lists of different types in the same 2D list.</p></div><p></p><h5 id="features-of-working-with-2d-lists">Features of working with 2D lists</h5><p>Let’s look at some useful and interesting features of working with two-dimensional lists. You remember that we can print all the elements of a list as a string using the <code class="language-kotlin">joinToString()</code> function. For nested lists, it will also work. Only now you must specify the index of the nested list that you want to convert to a string:</p><pre><code class="language-kotlin">val mutListString = mutableListOf(
    mutableListOf&lt;String&gt;("A", "R", "R", "A", "Y")
)
print(mutListString[0].joinToString())    // A, R, R, A, Y</code></pre><p>In the case of multi-dimensional lists, this will not always be convenient. In order to get the contents of all lists in a single string, you just print the main list:</p><pre><code class="language-kotlin">val mutListOfChar2D = mutableListOf(
mutableListOf&lt;Char&gt;('k'),
mutableListOf&lt;Char&gt;('o', 't'),
mutableListOf&lt;Char&gt;('l', 'i', 'n'))

println(mutListOfChar2D)	// [[k], [o, t], [l, i, n]]</code></pre><h5 id="multi-dimensional-lists-2">Multi-dimensional lists (&gt;2)</h5><p>We are finally ready to deal with more complex concepts. There are lists with more than two dimensions. Even though it is more difficult to understand what it looks like, don’t worry: you will get used to working with them.</p><p>You can imagine a three-dimensional list like this:</p><table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td><p>[0, 1]</p></td><td><p>[2, 3]</p></td></tr><tr><td><p>[4, 5]</p></td><td><p>[6, 7]</p></td></tr></tbody></table><p>In each element of a two-dimensional list, you have another nested list.</p><p>You can imagine it as a cube or a box: it has exactly three dimensions — length, width, and height. Take the following practical situation: imagine that you need to figure out the location of a car in a multi-storey parking lot. Then, you have to set three numbers, the three coordinates: floor, row, and place in a row.</p><p>The following code creates the three-dimensional mutable list you just saw above:</p><pre><code class="language-kotlin">val mutList3D = mutableListOf(
    mutableListOf(mutableListOf&lt;Int&gt;(0,1), mutableListOf&lt;Int&gt;(2,3)),
    mutableListOf(mutableListOf&lt;Int&gt;(4,5), mutableListOf&lt;Int&gt;(6,7))
)

println(mutList3D)  // [[[0, 1], [2, 3]], [[4, 5], [6, 7]]]</code></pre><p>Accordingly, in order to refer to an element of such a list, we need <strong>three</strong> indices:</p><pre><code class="language-kotlin">println(mutList3D[0][0][1])   // 1
println(mutList3D[1][0][1])   // 5
println(mutList3D[1][1][1])   // 7</code></pre><p>You can create lists with even more dimensions by analogy — 4, 5, 6 dimensions, and so on — as you need. Just remember that an element of a multidimensional list has as many indices as there are dimensions in that list.</p><h5 id="conclusion">Conclusion</h5><p>Let's recap. You have figured out what multi-dimensional lists are and how to create them in Kotlin. Here are the main points to take away:</p><ul><li><p>A multi-dimensional list is essentially a list of lists.</p></li><li><p>To find an element of a multi-dimensional list, you need a number of indices equal to the number of list dimensions.</p></li><li><p>You can explicitly specify nested lists of different types, not only <code class="language-kotlin">Int</code>.</p></li><li><p>You can assemble lists of different types and sizes in a multi-dimensional list.</p></li><li><p>To print all list elements, you can use the function <code class="language-kotlin">joinToString()</code>.</p></li><li><p>Indexing starts with 0.</p></li></ul>
